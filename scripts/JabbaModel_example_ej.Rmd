---
title: 'JABBA example'
author: Eglė Jakubavičiūtė and Asta Audzijonyte
date: '2022-11-23'
output: 
  html_document: 
    toc: yes
    theme: cerulean
---

JABBA requires the installation of [R](https://cran.r-project.org/) and [JAGS](https://sourceforge.net/projects/mcmc-jags/) and the following R packages that can be directly installed within R

```{r libraries, include=FALSE, eval = T, warning = F, message = F, echo = F}

## Loading packages and data

# Required packages (will install and load if not already)
list.of.packages <- 
  c("tidyverse", 
    "gplots", 
    "coda", 
    "rjags", 
    "R2jags", 
    "fitdistrplus",
    "reshape"
  )

new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages, dependencies = T)
lapply(list.of.packages, require, character.only = T)
rm(list.of.packages, new.packages)

## now install JABBA from github and load (uncomment lines below to install from github)

# # if (!require(devtools)){install.packages("devtools")}
# devtools::install_github("jabbamodel/JABBA")

library(JABBA)


```

## Data

JABBA requires a minimum of two input comma-separated value files (.csv) in the form of catch and abundance indices. The `Catch` input file contains the time series of year and catch by weight, aggregated across fleets for the entire fishery. Missing catch years or catch values are not allowed. JABBA is formulated to accommodate abundance indices from multiple sources (i.e., fleets) in a single `cpue` file, which contains all considered abundance indices. The first column of the `cpue` input is year, which must match the range of years provided in the Catch file. In contrast to the `Catch` input, missing abundance index values are allowed, such that different abundance indices may correspond to smaller portions of the catch time series. Optionally, an additional `se` input can be passed onto JABBA, containing standard error estimates associated with the abundance indices on a log scale. The se input is a third file, structurally identical to the `cpue` input. Alternatively, this feature can be used to apply different weighting to individual abundance indices by assigning varying coefficients of variation (CV) to each time series. If such weighting is implemented, it is advised that the CV chosen for each indexed year approximates the observed standard error on the log scale, such that the data weights are congruent with expectations as to how well the model should fit these data.

JABBA provides provides the option to use a single averaged CPUE index instead of the individual abundance indices (see *2.5.1. State-Space model for averaging of abundance indices* in Winker et al, 2018). This feature can be activated by setting `meanCPUE = TRUE`.

```{r, eval = T, echo = T, message = F, warning = F}
rm(list = ls()) # clear memory

all_data <- read.csv(file = here::here("scripts/StockA1_catch_cpueSE.csv"), fileEncoding="UTF-8-BOM") 

#inspect
head(all_data)

#which species do we have?
unique(all_data$Species)

```

#StockA1

```{r, eval = T, warning = F, message = T, echo = F}

species <- "StockA1"

## select one species
data <- all_data %>% filter (Species == species)

#indicate catch, cpue and SE of cpue
catch<-data %>% dplyr::select (Year, Total_catch)

cpue <- data %>% dplyr::select(Year, cpue_sc)
se <- data %>% dplyr::select(Year, cpue_SE)

colnames(catch) <- c("year", "catch")
colnames(cpue) <- c("year", "cpue")

colnames(se) <- c("year", "se")

plot(catch)
plot(cpue)
plot(se)


```

# SETUP AND RUN

### Setup model parameters

For surplus production models we basically need carrying capacity K and population growth rate r Since K and r are never known, a common approach is to set priors for K at 3-10 times the maximum catch in the catch time series, whereas r is assumed to be lognormally distributed with mean r of 0.2. But you can set it differently. Let's also make projections into the future assuming that catch in the next 10 years will stay the same as the last year's catch, be 50% smaller and 50% larger

```{r, eval = T, warning = F, message = T, echo = T}

# K range will be set is 3-10 times of maximum catch 
max(catch$catch)
Kmin <- as.numeric(3*max(catch$catch))
Kmax <- as.numeric(10*max(catch$catch))

#last year's catch
lastcatch <- round((1*as.numeric(catch[nrow(catch),][2])),0)
#Set the TAC_range
TAC_range <- c(0.5*lastcatch, lastcatch, 1.5*lastcatch)

#when to start projections with the new TAC range? Usually from the year after the last year
TAC_year <- catch$year[nrow(catch)] +1

```

#### setup: Schaeffer

```{r, eval = T, warning = F, message = F, echo = T}
scenario_name = "Schaeffer_both"

input_both_sch <- build_jabba(
  catch = catch,
  cpue = cpue,
  se = NULL,
  assessment = species,
  scenario = scenario_name,
  model.type = c("Schaefer", "Fox", "Pella", "Pella_m") [1],  # with [1] we select the first option
  add.catch.CV = TRUE,
  catch.cv = 0.1,
  catch.error = c("random", "under") [1],          #"under" mean directional underreporting
  Plim = 0.25,                                    #limit of biomass where recruitment can become impaired Plim = Blim/K
  r.dist = c("lnorm", "range")[1],
  r.prior = c(0.4, 0.2),             #IMPORTANT: What is the expected mean R and lognormal errors? Default is 0.2 and 0.25
  K.dist = c("lnorm", "range")[2],
  K.prior = c(Kmin,Kmax),
  psi.dist = c("lnorm", "beta")[1],
  psi.prior = c(0.6, 0.2),
  b.prior = c(FALSE, 0.3, NA, c("bk", "bbmsy", "ffmsy")[1]),
  BmsyK = 0.4,
  shape.CV = 0.3,
  sets.q = 1:(ncol(cpue) - 1),
  sigma.est = TRUE,
  sets.var = 1:(ncol(cpue) - 1),
  fixed.obsE = 0.01,
  #fixed.obsE = ifelse(is.null(se), 0.1, 0.001),
  sigma.proc = TRUE,
  proc.dev.all = TRUE,
  igamma = c(4, 0.01),
  projection = TRUE,
  TACs = TAC_range, # we set a range in here
  #TACs = c(350,1000), # optionally we can set a range in here
  TACint = NULL,
  imp.yr = TAC_year,        #when does TAC start
  pyrs = 10,            #how many years to project     
  P_bound = c(0.02, 1.3),
  sigmaobs_bound = 1,
  sigmaproc_bound = 0.2,
  q_bounds = c(10^-30, 1000),
  K_bounds = c(0.01, 10^10),
  harvest.label = c("Hmsy", "Fmsy")[2],
  catch.metric = "(t)"
)


```

#### Schaefer with CPUE SE

```{r,  eval = T, warning = F, message = F, echo = F}
scenario_name = "Schaeffer_both"

input_both_sch <- build_jabba(
  catch = catch,
  cpue = cpue,
  se = se,
  assessment = species,
  scenario = scenario_name,
  model.type = c("Schaefer", "Fox", "Pella", "Pella_m") [1],  # with [1] we select the first option
  add.catch.CV = TRUE,
  catch.cv = 0.1,
  catch.error = c("random", "under") [1],          #"under" mean directional underreporting
  Plim = 0.25,                                    #limit of biomass where recruitment can become impaired Plim = Blim/K
  r.dist = c("lnorm", "range")[1],
  r.prior = c(0.4, 0.2),             #IMPORTANT: What is the expected mean R and lognormal errors? Default is 0.2 and 0.25
  K.dist = c("lnorm", "range")[2],
  K.prior = c(Kmin,Kmax),
  psi.dist = c("lnorm", "beta")[1],
  psi.prior = c(0.6, 0.2),
  b.prior = c(FALSE, 0.3, NA, c("bk", "bbmsy", "ffmsy")[1]),
  BmsyK = 0.4,
  shape.CV = 0.3,
  sets.q = 1:(ncol(cpue) - 1),
  sigma.est = TRUE,
  sets.var = 1:(ncol(cpue) - 1),
  #fixed.obsE = 0.01,
  fixed.obsE = ifelse(is.null(se), 0.1, 0.001),
  sigma.proc = TRUE,
  proc.dev.all = TRUE,
  igamma = c(4, 0.01),
  projection = TRUE,
  TACs = TAC_range, # we set a range in here
  #TACs = c(350,1000), # we set a range in here
  TACint = NULL,
  imp.yr = TAC_year,        #when does TAC start
  pyrs = 10,            #how many years to project     
  P_bound = c(0.02, 1.3),
  sigmaobs_bound = 1,
  sigmaproc_bound = 0.2,
  q_bounds = c(10^-30, 1000),
  K_bounds = c(0.01, 10^10),
  harvest.label = c("Hmsy", "Fmsy")[2],
  catch.metric = "(t)"
)

```

#### setup: Fox

```{r,  eval = T, warning = F, message = F, echo = F}

scenario_name = "Fox_both"

input_both_fox <- build_jabba(
  catch = catch,
  cpue = cpue,
  se = NULL,
  assessment = species,
  scenario = scenario_name,
  model.type = c("Schaefer", "Fox", "Pella", "Pella_m") [2],  # with [1] we select the first option
  add.catch.CV = TRUE,
  catch.cv = 0.1,
  catch.error = c("random", "under") [1],          #"under" mean directional underreporting
  Plim = 0.25,                                    #limit of biomass where recruitment can become impaired Plim = Blim/K
  r.dist = c("lnorm", "range")[1],
  r.prior = c(0.25, 0.2),             #IMPORTANT: What is the expected mean R and lognormal errors? Default is 0.2 and 0.25
  K.dist = c("lnorm", "range")[2],
  K.prior = c(Kmin,Kmax),
  psi.dist = c("lnorm", "beta"),
  psi.prior = c(0.6, 0.2),
  b.prior = c(FALSE, 0.3, NA, c("bk", "bbmsy", "ffmsy")[1]),
  BmsyK = 0.4,
  shape.CV = 0.3,
  sets.q = 1:(ncol(cpue) - 1),
  sigma.est = TRUE,
  sets.var = 1:(ncol(cpue) - 1),
  fixed.obsE = 0.01,
  #fixed.obsE = ifelse(is.null(se), 0.1, 0.001),
  sigma.proc = TRUE,
  proc.dev.all = TRUE,
  igamma = c(4, 0.01),
  projection = TRUE,
  TACs = TAC_range, # we set a range in here
  #TACs = c(350,1000), # we set a range in here
  TACint = NULL,
  imp.yr = TAC_year,        #when does TAC start
  pyrs = 10,            #how many years to project     
  P_bound = c(0.02, 1.3),
  sigmaobs_bound = 1,
  sigmaproc_bound = 0.2,
  q_bounds = c(10^-30, 1000),
  K_bounds = c(0.01, 10^10),
  harvest.label = c("Hmsy", "Fmsy")[2],
  catch.metric = "(t)"
)

```

#### Fox with CPUE SE

```{r,  eval = T, warning = F, message = F, echo = F}

scenario_name = "Fox_both"

input_both_fox <- build_jabba(
  catch = catch,
  cpue = cpue,
  se = se,
  assessment = species,
  scenario = scenario_name,
  model.type = c("Schaefer", "Fox", "Pella", "Pella_m") [2],  # with [1] we select the first option
  add.catch.CV = TRUE,
  catch.cv = 0.1,
  catch.error = c("random", "under") [1],          #"under" mean directional underreporting
  Plim = 0.25,                                    #limit of biomass where recruitment can become impaired Plim = Blim/K
  r.dist = c("lnorm", "range")[1],
  r.prior = c(0.25, 0.2),             #IMPORTANT: What is the expected mean R and lognormal errors? Default is 0.2 and 0.25
  K.dist = c("lnorm", "range")[2],
  K.prior = c(Kmin,Kmax),
  psi.dist = c("lnorm", "beta"),
  psi.prior = c(0.6, 0.2),
  b.prior = c(FALSE, 0.3, NA, c("bk", "bbmsy", "ffmsy")[1]),
  BmsyK = 0.4,
  shape.CV = 0.3,
  sets.q = 1:(ncol(cpue) - 1),
  sigma.est = TRUE,
  sets.var = 1:(ncol(cpue) - 1),
  #fixed.obsE = 0.01,
  fixed.obsE = ifelse(is.null(se), 0.1, 0.001),
  sigma.proc = TRUE,
  proc.dev.all = TRUE,
  igamma = c(4, 0.01),
  projection = TRUE,
  TACs = TAC_range, # we set a range in here
  #TACs = c(350,1000), # we set a range in here
  TACint = NULL,
  imp.yr = TAC_year,        #when does TAC start
  pyrs = 10,            #how many years to project     
  P_bound = c(0.02, 1.3),
  sigmaobs_bound = 1,
  sigmaproc_bound = 0.2,
  q_bounds = c(10^-30, 1000),
  K_bounds = c(0.01, 10^10),
  harvest.label = c("Hmsy", "Fmsy")[2],
  catch.metric = "(t)"
)

```

#### setup: Pella

```{r,  eval = T, warning = F, message = F, echo = F}
scenario_name = "Pella_both"

input_both_pella <- build_jabba(
  catch = catch,
  cpue = cpue,
  se = NULL,
  assessment = species,
  scenario = scenario_name,
  model.type = c("Schaefer", "Fox", "Pella", "Pella_m") [3],  # with [1] we select the first option
  add.catch.CV = TRUE,
  catch.cv = 0.1,
  catch.error = c("random", "under") [1],          #"under" mean directional underreporting
  Plim = 0.25,                                    #limit of biomass where recruitment can become impaired Plim = Blim/K
  r.dist = c("lnorm", "range")[1],
  r.prior = c(0.25, 0.2),             #IMPORTANT: What is the expected mean R and lognormal errors? Default is 0.2 and 0.25
  K.dist = c("lnorm", "range")[2],
  K.prior = c(Kmin,Kmax),
  psi.dist = c("lnorm", "beta"),
  psi.prior = c(0.6, 0.2),
  b.prior = c(FALSE, 0.3, NA, c("bk", "bbmsy", "ffmsy")[1]),
  BmsyK = 0.4,
  shape.CV = 0.3,
  sets.q = 1:(ncol(cpue) - 1),
  sigma.est = TRUE,
  sets.var = 1:(ncol(cpue) - 1),
  fixed.obsE = 0.01,
  #fixed.obsE = ifelse(is.null(se), 0.1, 0.001),
  sigma.proc = TRUE,
  proc.dev.all = TRUE,
  igamma = c(4, 0.01),
  projection = TRUE,
  TACs = TAC_range, # we set a range in here
  #TACs = c(350,1000), # we set a range in here
  TACint = NULL,
  imp.yr = TAC_year,        #when does TAC start
  pyrs = 10,            #how many years to project     
  P_bound = c(0.02, 1.3),
  sigmaobs_bound = 1,
  sigmaproc_bound = 0.2,
  q_bounds = c(10^-30, 1000),
  K_bounds = c(0.01, 10^10),
  harvest.label = c("Hmsy", "Fmsy")[2],
  catch.metric = "(t)"
)

```

#### Pella with CPUE SE

```{r,  eval = T, warning = F, message = F, echo = F}
scenario_name = "Pella_both"

input_both_pella <- build_jabba(
  catch = catch,
  cpue = cpue,
  se = se,
  assessment = species,
  scenario = scenario_name,
  model.type = c("Schaefer", "Fox", "Pella", "Pella_m") [3],  # with [1] we select the first option
  add.catch.CV = TRUE,
  catch.cv = 0.1,
  catch.error = c("random", "under") [1],          #"under" mean directional underreporting
  Plim = 0.25,                                    #limit of biomass where recruitment can become impaired Plim = Blim/K
  r.dist = c("lnorm", "range")[1],
  r.prior = c(0.25, 0.2),             #IMPORTANT: What is the expected mean R and lognormal errors? Default is 0.2 and 0.25
  K.dist = c("lnorm", "range")[2],
  K.prior = c(Kmin,Kmax),
  psi.dist = c("lnorm", "beta"),
  psi.prior = c(0.6, 0.2),
  b.prior = c(FALSE, 0.3, NA, c("bk", "bbmsy", "ffmsy")[1]),
  BmsyK = 0.4,
  shape.CV = 0.3,
  sets.q = 1:(ncol(cpue) - 1),
  sigma.est = TRUE,
  sets.var = 1:(ncol(cpue) - 1),
  #fixed.obsE = 0.01,
  fixed.obsE = ifelse(is.null(se), 0.1, 0.001),
  sigma.proc = TRUE,
  proc.dev.all = TRUE,
  igamma = c(4, 0.01),
  projection = TRUE,
  TACs = TAC_range, # we set a range in here
  #TACs = c(350,1000), # we set a range in here
  TACint = NULL,
  imp.yr = TAC_year,        #when does TAC start
  pyrs = 10,            #how many years to project     
  P_bound = c(0.02, 1.3),
  sigmaobs_bound = 1,
  sigmaproc_bound = 0.2,
  q_bounds = c(10^-30, 1000),
  K_bounds = c(0.01, 10^10),
  harvest.label = c("Hmsy", "Fmsy")[2],
  catch.metric = "(t)"
)

```

# RUN

We will run Schaefer, Fox and Pella scenarios. They make different assumptions about density dependence. We run them with identical parameters and priors, but we expect to get different posterior estimates, because they assume a slightly different production curve

### Run: Schaeffer


```{r,  eval = F, warning = F, message = F, echo = F}

# creating a directory to save the output files
dir.create(species) 


#note this will save an .RData object 

run_both_sch <- fit_jabba(
  input_both_sch,
  ni = 30000,
  nt = 5,
  nb = 5000,
  nc = 2,
  init.values = FALSE,
  init.K = NULL,
  init.r = NULL,
  init.q = NULL,
  peels = NULL,
  save.all = FALSE,
  save.trj = TRUE,
  save.jabba = TRUE,  #will save the RData object
  save.csvs = TRUE,
  output.dir = species,  ## make sure you create a folder in your working directory to save outputs
  quickmcmc = TRUE
)
```

### Run: Fox

```{r, eval = F, warning = F, message = F, echo = F}


run_both_fox <- fit_jabba(
  input_both_fox,
  ni = 30000,
  nt = 5,
  nb = 5000,
  nc = 2,
  init.values = FALSE,
  init.K = NULL,
  init.r = NULL,
  init.q = NULL,
  peels = NULL,
  save.all = FALSE,
  save.trj = TRUE,
  save.jabba = TRUE,  #will save the RData object
  save.csvs = TRUE,
  output.dir = species,  ## make sure you create a folder in your working directory to save outputs
  quickmcmc = TRUE
)


```

### Run: Pella

```{r, eval = F, warning = F, message = F, echo = F}
run_both_pella <- fit_jabba(
  input_both_pella,
  ni = 30000,
  nt = 5,
  nb = 5000,
  nc = 2,
  init.values = FALSE,
  init.K = NULL,
  init.r = NULL,
  init.q = NULL,
  peels = NULL,
  save.all = FALSE,
  save.trj = TRUE,
  save.jabba = TRUE,  #will save the RData object
  save.csvs = TRUE,
  output.dir = species,  ## make sure you create a folder in your working directory to save outputs
  quickmcmc = TRUE
)

```

# MAKE OUTPUTS

### all output plots into directory

You can explore these plots from the working directory

```{r, eval = T, warning = F, message = T, echo = T}

jabba_plots(run_both_sch, output.dir = species)
#jabba_plots(run_both_fox, output.dir = species)
#jabba_plots(run_both_pella, output.dir = species)


```

### summary plot in pdf

If you want to generate your summary plot

```{r, eval = T, warning = F, message = T, echo = T}
#load the data file, but it is always saved as name "jabba". Chose which file you want: Schaeffer, Fox or Pella

 load(file = paste0(species,"/",species,"_Schaeffer_both_jabba.rdata"))
#load(file = paste0(species,"/",species,"_Fox_both_jabba.rdata"))
# load(file = paste0(species,"/",species,"_Pella_both_jabba.rdata"))

 #rename it, to not get confused
 model_out <- jabba

 #make a name for a summary pdf file 
pdf(file = paste0(species,"/",species,"_summary.pdf"), width = 11, height = 12)

# plot various outputs 

par(mfrow=c(3,2),mar = c(5, 5, 4, 3))
jbplot_trj(model_out,type="BBmsy",add=T)
jbplot_trj(model_out,type="F",add=T)
jbplot_catch(model_out, add = T)
jbplot_spphase(model_out,add=T)
jbplot_kobe(model_out, add = T)

dev.off()

```
